/*!
    *
    * Wijmo Library 5.20242.21
    * https://developer.mescius.com/wijmo
    *
    * Copyright(c) MESCIUS inc. All rights reserved.
    *
    * Licensed under the End-User License Agreement For MESCIUS Wijmo Software.
    * us.sales@mescius.com
    * https://developer.mescius.com/wijmo/licensing
    *
    */
/**
 * {@module wijmo.react.base}
 * Contains base classes for all Wijmo for React directives.
 */
/**
 *
 */
export declare var ___keepComment: any;
import { CancelEventArgs, Control, EventArgs, IEventHandler } from '@mescius/wijmo';
/**
* From 5.20241.19, React interop now supports strict state mode.
* This means that on each re-render cycle, all of the component properties
* get synced with their values provided in the JSX.
* Setting properties via JSX will make that prop externally controlled, and
* changing its value will be allowed only by updating the state variables passed in JSX.
*
* By default, this option is set to false to maintain compatibility with existing user applications.
* If users want to utilize the Wijmo API in accordance with React's state management philosophy,
* they can set **strictStateMode** to true.
*
* When the strictStateMode flag is false, the value of the underlying component gets synced only when
* the prop value changes and not when the component re-renders. This makes it possible for JSX to become
* out of sync with the rendered state.
*
* Consider the following: if you set the value on an input control like {@link InputDate} and if strictStateMode
* is false, it is possible to select a different value in the control. After the value is selected,
* there is a mismatch between the React-provided state and the rendered state. This leads to potential bugs.
* That is why React recommends using controlled components. In controlled components, once the value is
* provided externally via JSX, the control value is not allowed to change unless the externally provided value
* is changed itself. So in the above scenario (for strictStateMode = true), to be able to change the value,
* we need to handle the valueChanged event and update the state variable to update the controlled value.
*
* ```typescript
* function App() {
*   const [date, setDate] = useState(new Date());
*
*   return (
*     <div>
*       <InputDate value={date} valueChanged={(s) => setDate(s.value)} />
*     </div>
*   );
* }
* ```
*
* @param value Whether to use the strict state mode or not
*/
export declare function strictStateMode(value?: boolean): void;
export declare type Overwrite<T, U> = Pick<T, Exclude<keyof T, keyof U>> & U;
export declare type WjRef<T> = {
    control: T;
    props: any;
};
export declare type ControlBaseEvents<T> = {
    gotFocus?: IEventHandler<T, EventArgs>;
    invalidInput?: IEventHandler<T, CancelEventArgs>;
    lostFocus?: IEventHandler<T, EventArgs>;
    refreshed?: IEventHandler<T, EventArgs>;
    refreshing?: IEventHandler<T, EventArgs>;
};
export declare type ControlBaseInputs = {
    isDisabled?: boolean;
    tabOrder?: number;
    initialized?: any;
    [key: string]: any;
    children?: any;
};
export declare type BaseInputs = {
    initialized?: any;
    ref?: any;
};
export declare const ControlBaseMeta: {
    inputs: string[];
    events: string[];
};
export declare function useWjComponentBase(initInfo: {
    properties: string[];
    events: string[];
    customProps?: {
        [key: string]: (control: any, value: any) => void;
    };
    constructor: typeof Control;
    props: any;
    ref?: any;
    prePropsInit?: (control: any) => void;
    initControl?: (control: any) => void;
}): {
    renderResult: any;
    wjControl: any;
};
export declare function useWjComponentChildBase(initInfo: {
    ref?: any;
    properties: string[];
    events: string[];
    constructor: any;
    props: any;
    needParentInstance: boolean;
    parentProp: string;
    isParentPropArray: boolean;
    assignedToParent: boolean;
    customConstructor?: (parent: any, initData: any, customPropData?: any) => any;
    customProps?: {
        [key: string]: (control: any, value: any) => void;
    };
}): {
    getInstance: (parentProp?: any) => {
        instance: any;
        updateProps: (props: any) => void;
    };
    props: any;
    parentProp: string;
    wjProperty: any;
    isParentPropArray: boolean;
    assignedToParent: boolean;
};
export declare function selectiveDomRender(component: any, host: HTMLElement, useMicroTask?: boolean): HTMLElement;
export declare function selectiveDomUnmount(host?: HTMLElement): void;
export declare function baseFlushSync(): void;
