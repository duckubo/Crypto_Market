/*!
    *
    * Wijmo Library 5.20242.21
    * https://developer.mescius.com/wijmo
    *
    * Copyright(c) MESCIUS inc. All rights reserved.
    *
    * Licensed under the End-User License Agreement For MESCIUS Wijmo Software.
    * us.sales@mescius.com
    * https://developer.mescius.com/wijmo/licensing
    *
    */

"use strict";var __awaiter=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(o,s){function fulfilled(e){try{step(r.next(e))}catch(e){s(e)}}function rejected(e){try{step(r.throw(e))}catch(e){s(e)}}function step(e){e.done?o(e.value):new n((function(t){t(e.value)})).then(fulfilled,rejected)}step((r=r.apply(e,t||[])).next())}))},__importStar=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.hasOwnProperty.call(e,n)&&(t[n]=e[n]);t.default=e;return t};Object.defineProperty(exports,"__esModule",{value:!0});const wijmo_1=require("@mescius/wijmo"),ReactDOM=__importStar(require("react-dom")),React=__importStar(require("react")),flushSyncPolyfill=e=>{e()},createRootPolyfill=()=>{throw"Wijmo: React dependencies not loaded properly"},ReactDomPolyfill={flushSync:flushSyncPolyfill,createRoot:createRootPolyfill};let reactDomClient=ReactDOM||ReactDomPolyfill,flushSync=reactDomClient.flushSync;function lazyImportDomClient(){return __awaiter(this,void 0,void 0,(function*(){try{const e=require("react-dom/client");reactDomClient=e||ReactDOM||ReactDomPolyfill;flushSync=e.flushSync||flushSync}catch(e){reactDomClient=ReactDOM||ReactDomPolyfill}}))}let _oldSyncBehavior=!0;function strictStateMode(e=!1){e==_oldSyncBehavior&&(_oldSyncBehavior=!wijmo_1.asBoolean(e,!1))}exports.strictStateMode=strictStateMode;exports.ControlBaseMeta={inputs:["isDisabled","tabOrder"],events:["gotFocus","invalidInput","lostFocus","refreshed","refreshing"]};const alwaysClearProps=new Set(["columns","columnGroups"]),unsuppressedChangedEventProps=new Set(["panes","columnGroups","columns","items"]),specialProps=new Set(["initialized","wjItemTemplate"]);function updateChildProperties(e,t){const n=e.controlRef.current,r={},o={};if(t){const s=wijmo_1.isArray(t)?t.flat(1/0):[t],c=[];let i=0;const l=new Set;for(let e of s){if(e&&e.type&&e.type.$$typeof==Symbol.for("react.forward_ref")){c.push(e.type.render(e.props,e.ref));c[c.length-1].$index=i;c[c.length-1].$key=e.key}else if(e&&wijmo_1.isFunction(e.type)){c.push(e.type(e.props));c[c.length-1].$index=i;c[c.length-1].$key=e.key}e||l.add(i);i++}const a=[];for(let e of c)if(e.assignedToParent){if(e.wjProperty){e.parentProp=wijmo_1.asString(e.wjProperty);e.isParentPropArray=n[e.parentProp]&&wijmo_1.isArray(n[e.parentProp])}e.isParentPropArray&&!r[e.parentProp]&&(r[e.parentProp]=[]);e.isParentPropArray?r[e.parentProp].push({getInstance:e.getInstance,props:e.props,$key:e.$key,$index:e.$index}):r[e.parentProp]={getInstance:e.getInstance,props:e.props}}else a.push(e);const u=e.childInfo;for(let e in r)if(wijmo_1.isArray(r[e])){let t=!1;if(n[e]&&null!=n[e]._updating&&!unsuppressedChangedEventProps.has(e)){n[e]._updating++;t=!0}let s=u[e];o[e]=[];if(!u[e]){s=[];n[e]&&n[e].clear?n[e].clear():n[e]||(n[e]=new wijmo_1.ObservableArray)}!_oldSyncBehavior&&alwaysClearProps.has(e)&&n[e]&&n[e].clear&&n[e].clear();if(_oldSyncBehavior)for(let t=s.length-1;t>=0;t--)if(l.has(s[t].$index)){n[e].remove(s[t].instance);s.splice(t,1)}const c=[],i={};for(let e of s)null!=e.$key?i[""+e.$key]=e:c.push(e);let a=0;const getExistingInstance=(e=null)=>{if(null!=e){let t=i[e];null!=t&&delete i[e];return t}return c[a++]};for(let t=0;t<r[e].length;t++){let s=getExistingInstance(r[e][t].$key),c=!1;if(s)s.updateProps(r[e][t].props);else{s=r[e][t].getInstance(n);c=!0}s.$index=r[e][t].$index;s.$key=r[e][t].$key;(!_oldSyncBehavior&&alwaysClearProps.has(e)||c)&&(n[e].length==t?n[e].push(s.instance):n[e].splice(t,0,s.instance));o[e].push(s)}for(let t of Object.keys(i))n[e].remove(i[t].instance);for(;!_oldSyncBehavior&&n[e].length>o[e].length;)n[e].pop();if(t){n[e]._updating--;u[e]&&u[e].length==r[e].length||n[e]._raiseCollectionChanged&&n[e]._raiseCollectionChanged()}}else{let t=u[e];if(t)t.updateProps(r[e].props);else{t=r[e].getInstance(n);n[e]=t.instance}o[e]=t}const p=[];for(let e of u.$_nonassignable||[])l.has(e.$index)?e.instance&&e.instance.dispose&&wijmo_1.isFunction(e.instance.dispose)&&e.instance.dispose():p.push(e);const f=[];let d=0;for(;d<a.length;d++){let e=p[d];e?e.updateProps(a[d].props):e=a[d].getInstance(n);e.$index=a[d].$index;f.push(e)}o.$_nonassignable=f;for(;d<p.length;d++)p[d].instance&&p[d].instance.dispose&&wijmo_1.isFunction(p[d].instance.dispose)&&p[d].instance.dispose()}if(_oldSyncBehavior)for(let t of Object.keys(e.childInfo))if(wijmo_1.isArray(e.childInfo[t])&&!r[t]&&n[t]&&n[t].remove)for(let r of e.childInfo[t])n[t].remove(r.instance);return o}function getPropsAccordingToSyncMode(e,t,n=null){if(!t||!_oldSyncBehavior){return Object.assign({},e)}let r={};for(let o in e){let s=!1;n&&(s=n.knowProperties.has(o)||n.knowEvents.has(o)||n.knowCustomProps.has(o));(n&&!s||e[o]!==t[o])&&(r[o]=e[o])}return r}function useWjComponentBase(e){const t=React.useRef({}),n=React.useRef(),r=React.useRef(),o=React.useRef(),s=React.useRef(),c=React.useRef({}),i=React.useRef(!1);e.customProps||(e.customProps={});if(!n.current){n.current={};n.current.knowProperties=new Set(e.properties);n.current.knowEvents=new Set(e.events);n.current.knowCustomProps=new Set(Object.keys(e.customProps))}let l=e.props;if(s.current){l=getPropsAccordingToSyncMode(e.props,t.current,n.current);t.current=e.props}const a={},u={},p={},f={},d=e.ref||null;for(let t in l)if(n.current.knowProperties.has(t))a[t]=l[t];else if(n.current.knowEvents.has(t)){u[t]=l[t];a[t]=l[t]}else e.customProps[t]?f[t]=l[t]:specialProps.has(t)||(p[t]=l[t]);if(s.current&&_oldSyncBehavior)for(let e in u)delete a[e];const updateProps=()=>{d&&d.current&&(d.current.props=e.props);updateChildProps();let t=[],n=a;if(o.current&&s.current&&!_oldSyncBehavior){for(let e in o.current)if(s.current[e]){if(s.current[e]._handlersChanged){s.current[e]._cachedHandlersChanged=s.current[e]._handlersChanged;s.current[e]._handlersChanged=null;t.push(s.current[e])}s.current[e].removeHandler(o.current[e])}n=Object.assign({},a);for(let e in u){delete n[e];s.current[e].addHandler(u[e])}}else if(!o.current){n=Object.assign({},a);for(let e in u)delete n[e]}o.current=u;if(s.current){wijmo_1.copy(s.current,n,!1,!0);for(let t in f)e.customProps[t](s.current,f[t]);(()=>{for(let e of t)if(e._cachedHandlersChanged){e._handlersChanged=e._cachedHandlersChanged;e._cachedHandlersChanged=null}t=[]})()}},updateChildProps=()=>{c.current=updateChildProperties({controlRef:s,childInfo:c.current},e.props.children)};React.useLayoutEffect(()=>{if(r.current&&!s.current){s.current=new e.constructor(r.current,a);e.prePropsInit&&e.prePropsInit(s.current);d&&(wijmo_1.isFunction(d)?d({control:s.current,props:e.props}):d.current&&d.current.control==s.current||(d.current={control:s.current,props:e.props}));updateProps();e.initControl&&e.initControl(s.current);e.props.initialized&&setTimeout(()=>{s.current&&e.props.initialized(s.current)})}else i.current&&(i.current=!1);return()=>{if(s.current){const e=s.current;i.current=!0;queueMicrotask(()=>{if(i.current){e.dispose();s.current=null;c.current={};i.current=!1}})}}},[]);s.current&&updateProps();return{renderResult:React.createElement("div",Object.assign({ref:r},p),[]),wjControl:s.current}}exports.useWjComponentBase=useWjComponentBase;function filterKnownProps(e,t,n){const r={};for(let o in e)(t.has(o)||n.has(o))&&(r[o]=e[o]);return r}function clearAndGetEvents(e,t,n,r){const o=r.current,s={};for(let e in t)n.has(e)&&(s[e]=t[e]);for(let n in o)e[n]&&(!_oldSyncBehavior||t[n]?e[n].removeHandler(o[n]):s[n]=o[n]);return s}function getCustomPropsData(e,t){const n={};for(let r in t)void 0!==e[r]&&(n[r]=e[r]);return n}function useWjComponentChildBase(e){const t={};t.knowProperties=new Set(e.properties);t.knowEvents=new Set(e.events);e.customProps||(e.customProps={});return{getInstance:n=>{const r={current:{}},o={current:{}},s={current:{}},c=getPropsAccordingToSyncMode(e.props,r.current),i=filterKnownProps(c,t.knowProperties,t.knowEvents),l=getCustomPropsData(c,e.customProps||{}),a=e.customConstructor?e.customConstructor(n,i,l):new e.constructor(e.needParentInstance?n:i,e.needParentInstance?i:void 0);e.ref&&(wijmo_1.isFunction(e.ref)?e.ref({control:a,props:e.props}):e.ref.current&&e.ref.current.control==a||(e.ref.current={control:a,props:e.props}));s.current=clearAndGetEvents(a,c,t.knowEvents,s);const updateProps=n=>{const c=getPropsAccordingToSyncMode(n,r.current);r.current=n;e.ref&&e.ref.current&&(e.ref.current.props=n);s.current=clearAndGetEvents(a,c,t.knowEvents,s);const i=filterKnownProps(c,t.knowProperties,t.knowEvents);a.initialize?a.initialize(i):wijmo_1.copy(a,i,!1,!0);for(let t in e.customProps)void 0!==c[t]&&e.customProps[t](a,c[t]);(e=>{o.current=updateChildProperties({controlRef:{current:a},childInfo:o.current},e)})(n.children||[])};updateProps(e.props||[]);e.props.initialized&&wijmo_1.isFunction(e.props.initialized)&&e.props.initialized(a);return{instance:a,updateProps:updateProps}},props:e.props,parentProp:e.parentProp,wjProperty:e.props.wjProperty,isParentPropArray:e.isParentPropArray,assignedToParent:e.assignedToParent}}exports.useWjComponentChildBase=useWjComponentChildBase;let _reactMajorVersion,elemRootMap=[];if(!_reactMajorVersion){const e=parseInt(React.version);_reactMajorVersion=e;e>=18&&lazyImportDomClient()}const flushSyncStateCache={isReactRendering:null};function isReactRendering(){if(null==flushSyncStateCache.isReactRendering)try{const e=console.error;let t=!1;console.error=function(){const e=arguments[0]||"";e.includes("flushSync")&&(t=!0)};flushSync(()=>{});console.error=e;flushSyncStateCache.isReactRendering=t}catch(e){}finally{queueMicrotask(()=>{flushSyncStateCache.isReactRendering=null})}return!!flushSyncStateCache.isReactRendering}function getReactDOM(){return ReactDOM}function selectiveDomRender(e,t,n=!1){if(_reactMajorVersion<18){(0,getReactDOM().render)(e,t)}else{isReactRendering()&&(n=!0);const r=elemRootMap.findIndex(e=>e.host===t);let o;if(-1===r){o=reactDomClient.createRoot(t);elemRootMap.push({host:t,root:o})}else o=elemRootMap[r].root;o.__scheduledForUnmount=!1;n?queueMicrotask(()=>{flushSync(()=>{o.render(e)})}):flushSync(()=>{o.render(e)})}return t}exports.selectiveDomRender=selectiveDomRender;function unmountSafely(e){const t=e._internalRoot&&e._internalRoot.containerInfo.firstChild,n=e._internalRoot&&e._internalRoot.current&&e._internalRoot.current.child&&e._internalRoot.current.child.stateNode;n&&t==n?e.unmount():e._internalRoot=null;e.__scheduledForUnmount=null}function selectiveDomUnmount(e){if(_reactMajorVersion<18){(0,getReactDOM().unmountComponentAtNode)(e)}else{const t=elemRootMap.findIndex(t=>t.host===e);if(-1!==t){const e=elemRootMap[t].root;if(isReactRendering()){e.__scheduledForUnmount=!0;queueMicrotask(()=>{e.__scheduledForUnmount&&flushSync(()=>{unmountSafely(e);elemRootMap.splice(t,1)})})}else flushSync(()=>{unmountSafely(e);elemRootMap.splice(t,1)})}}}exports.selectiveDomUnmount=selectiveDomUnmount;function baseFlushSync(){flushSync(()=>{})}exports.baseFlushSync=baseFlushSync;