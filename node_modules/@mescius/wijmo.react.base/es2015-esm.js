/*!
    *
    * Wijmo Library 5.20242.21
    * https://developer.mescius.com/wijmo
    *
    * Copyright(c) MESCIUS inc. All rights reserved.
    *
    * Licensed under the End-User License Agreement For MESCIUS Wijmo Software.
    * us.sales@mescius.com
    * https://developer.mescius.com/wijmo/licensing
    *
    */

var __awaiter=this&&this.__awaiter||function(e,n,r,t){return new(r||(r=Promise))((function(o,s){function fulfilled(e){try{step(t.next(e))}catch(e){s(e)}}function rejected(e){try{step(t.throw(e))}catch(e){s(e)}}function step(e){e.done?o(e.value):new r((function(n){n(e.value)})).then(fulfilled,rejected)}step((t=t.apply(e,n||[])).next())}))};import{ObservableArray,asString,copy,isArray,isFunction,asBoolean}from"@mescius/wijmo";import*as ReactDOM from"react-dom";import*as React from"react";const flushSyncPolyfill=e=>{e()},createRootPolyfill=()=>{throw"Wijmo: React dependencies not loaded properly"},ReactDomPolyfill={flushSync:flushSyncPolyfill,createRoot:createRootPolyfill};let reactDomClient=ReactDOM||ReactDomPolyfill,flushSync=reactDomClient.flushSync;function lazyImportDomClient(){return __awaiter(this,void 0,void 0,(function*(){try{const e=require("react-dom/client");reactDomClient=e||ReactDOM||ReactDomPolyfill;flushSync=e.flushSync||flushSync}catch(e){reactDomClient=ReactDOM||ReactDomPolyfill}}))}let _oldSyncBehavior=!0;export function strictStateMode(e=!1){e==_oldSyncBehavior&&(_oldSyncBehavior=!asBoolean(e,!1))}export const ControlBaseMeta={inputs:["isDisabled","tabOrder"],events:["gotFocus","invalidInput","lostFocus","refreshed","refreshing"]};const alwaysClearProps=new Set(["columns","columnGroups"]),unsuppressedChangedEventProps=new Set(["panes","columnGroups","columns","items"]),specialProps=new Set(["initialized","wjItemTemplate"]);function updateChildProperties(e,n){const r=e.controlRef.current,t={},o={};if(n){const s=isArray(n)?n.flat(1/0):[n],c=[];let i=0;const l=new Set;for(let e of s){if(e&&e.type&&e.type.$$typeof==Symbol.for("react.forward_ref")){c.push(e.type.render(e.props,e.ref));c[c.length-1].$index=i;c[c.length-1].$key=e.key}else if(e&&isFunction(e.type)){c.push(e.type(e.props));c[c.length-1].$index=i;c[c.length-1].$key=e.key}e||l.add(i);i++}const a=[];for(let e of c)if(e.assignedToParent){if(e.wjProperty){e.parentProp=asString(e.wjProperty);e.isParentPropArray=r[e.parentProp]&&isArray(r[e.parentProp])}e.isParentPropArray&&!t[e.parentProp]&&(t[e.parentProp]=[]);e.isParentPropArray?t[e.parentProp].push({getInstance:e.getInstance,props:e.props,$key:e.$key,$index:e.$index}):t[e.parentProp]={getInstance:e.getInstance,props:e.props}}else a.push(e);const u=e.childInfo;for(let e in t)if(isArray(t[e])){let n=!1;if(r[e]&&null!=r[e]._updating&&!unsuppressedChangedEventProps.has(e)){r[e]._updating++;n=!0}let s=u[e];o[e]=[];if(!u[e]){s=[];r[e]&&r[e].clear?r[e].clear():r[e]||(r[e]=new ObservableArray)}!_oldSyncBehavior&&alwaysClearProps.has(e)&&r[e]&&r[e].clear&&r[e].clear();if(_oldSyncBehavior)for(let n=s.length-1;n>=0;n--)if(l.has(s[n].$index)){r[e].remove(s[n].instance);s.splice(n,1)}const c=[],i={};for(let e of s)null!=e.$key?i[""+e.$key]=e:c.push(e);let a=0;const getExistingInstance=(e=null)=>{if(null!=e){let n=i[e];null!=n&&delete i[e];return n}return c[a++]};for(let n=0;n<t[e].length;n++){let s=getExistingInstance(t[e][n].$key),c=!1;if(s)s.updateProps(t[e][n].props);else{s=t[e][n].getInstance(r);c=!0}s.$index=t[e][n].$index;s.$key=t[e][n].$key;(!_oldSyncBehavior&&alwaysClearProps.has(e)||c)&&(r[e].length==n?r[e].push(s.instance):r[e].splice(n,0,s.instance));o[e].push(s)}for(let n of Object.keys(i))r[e].remove(i[n].instance);for(;!_oldSyncBehavior&&r[e].length>o[e].length;)r[e].pop();if(n){r[e]._updating--;u[e]&&u[e].length==t[e].length||r[e]._raiseCollectionChanged&&r[e]._raiseCollectionChanged()}}else{let n=u[e];if(n)n.updateProps(t[e].props);else{n=t[e].getInstance(r);r[e]=n.instance}o[e]=n}const p=[];for(let e of u.$_nonassignable||[])l.has(e.$index)?e.instance&&e.instance.dispose&&isFunction(e.instance.dispose)&&e.instance.dispose():p.push(e);const f=[];let d=0;for(;d<a.length;d++){let e=p[d];e?e.updateProps(a[d].props):e=a[d].getInstance(r);e.$index=a[d].$index;f.push(e)}o.$_nonassignable=f;for(;d<p.length;d++)p[d].instance&&p[d].instance.dispose&&isFunction(p[d].instance.dispose)&&p[d].instance.dispose()}if(_oldSyncBehavior)for(let n of Object.keys(e.childInfo))if(isArray(e.childInfo[n])&&!t[n]&&r[n]&&r[n].remove)for(let t of e.childInfo[n])r[n].remove(t.instance);return o}function getPropsAccordingToSyncMode(e,n,r=null){if(!n||!_oldSyncBehavior){return Object.assign({},e)}let t={};for(let o in e){let s=!1;r&&(s=r.knowProperties.has(o)||r.knowEvents.has(o)||r.knowCustomProps.has(o));(r&&!s||e[o]!==n[o])&&(t[o]=e[o])}return t}export function useWjComponentBase(e){const n=React.useRef({}),r=React.useRef(),t=React.useRef(),o=React.useRef(),s=React.useRef(),c=React.useRef({}),i=React.useRef(!1);e.customProps||(e.customProps={});if(!r.current){r.current={};r.current.knowProperties=new Set(e.properties);r.current.knowEvents=new Set(e.events);r.current.knowCustomProps=new Set(Object.keys(e.customProps))}let l=e.props;if(s.current){l=getPropsAccordingToSyncMode(e.props,n.current,r.current);n.current=e.props}const a={},u={},p={},f={},d=e.ref||null;for(let n in l)if(r.current.knowProperties.has(n))a[n]=l[n];else if(r.current.knowEvents.has(n)){u[n]=l[n];a[n]=l[n]}else e.customProps[n]?f[n]=l[n]:specialProps.has(n)||(p[n]=l[n]);if(s.current&&_oldSyncBehavior)for(let e in u)delete a[e];const updateProps=()=>{d&&d.current&&(d.current.props=e.props);updateChildProps();let n=[],r=a;if(o.current&&s.current&&!_oldSyncBehavior){for(let e in o.current)if(s.current[e]){if(s.current[e]._handlersChanged){s.current[e]._cachedHandlersChanged=s.current[e]._handlersChanged;s.current[e]._handlersChanged=null;n.push(s.current[e])}s.current[e].removeHandler(o.current[e])}r=Object.assign({},a);for(let e in u){delete r[e];s.current[e].addHandler(u[e])}}else if(!o.current){r=Object.assign({},a);for(let e in u)delete r[e]}o.current=u;if(s.current){copy(s.current,r,!1,!0);for(let n in f)e.customProps[n](s.current,f[n]);(()=>{for(let e of n)if(e._cachedHandlersChanged){e._handlersChanged=e._cachedHandlersChanged;e._cachedHandlersChanged=null}n=[]})()}},updateChildProps=()=>{c.current=updateChildProperties({controlRef:s,childInfo:c.current},e.props.children)};React.useLayoutEffect(()=>{if(t.current&&!s.current){s.current=new e.constructor(t.current,a);e.prePropsInit&&e.prePropsInit(s.current);d&&(isFunction(d)?d({control:s.current,props:e.props}):d.current&&d.current.control==s.current||(d.current={control:s.current,props:e.props}));updateProps();e.initControl&&e.initControl(s.current);e.props.initialized&&setTimeout(()=>{s.current&&e.props.initialized(s.current)})}else i.current&&(i.current=!1);return()=>{if(s.current){const e=s.current;i.current=!0;queueMicrotask(()=>{if(i.current){e.dispose();s.current=null;c.current={};i.current=!1}})}}},[]);s.current&&updateProps();return{renderResult:React.createElement("div",Object.assign({ref:t},p),[]),wjControl:s.current}}function filterKnownProps(e,n,r){const t={};for(let o in e)(n.has(o)||r.has(o))&&(t[o]=e[o]);return t}function clearAndGetEvents(e,n,r,t){const o=t.current,s={};for(let e in n)r.has(e)&&(s[e]=n[e]);for(let r in o)e[r]&&(!_oldSyncBehavior||n[r]?e[r].removeHandler(o[r]):s[r]=o[r]);return s}function getCustomPropsData(e,n){const r={};for(let t in n)void 0!==e[t]&&(r[t]=e[t]);return r}export function useWjComponentChildBase(e){const n={};n.knowProperties=new Set(e.properties);n.knowEvents=new Set(e.events);e.customProps||(e.customProps={});return{getInstance:r=>{const t={current:{}},o={current:{}},s={current:{}},c=getPropsAccordingToSyncMode(e.props,t.current),i=filterKnownProps(c,n.knowProperties,n.knowEvents),l=getCustomPropsData(c,e.customProps||{}),a=e.customConstructor?e.customConstructor(r,i,l):new e.constructor(e.needParentInstance?r:i,e.needParentInstance?i:void 0);e.ref&&(isFunction(e.ref)?e.ref({control:a,props:e.props}):e.ref.current&&e.ref.current.control==a||(e.ref.current={control:a,props:e.props}));s.current=clearAndGetEvents(a,c,n.knowEvents,s);const updateProps=r=>{const c=getPropsAccordingToSyncMode(r,t.current);t.current=r;e.ref&&e.ref.current&&(e.ref.current.props=r);s.current=clearAndGetEvents(a,c,n.knowEvents,s);const i=filterKnownProps(c,n.knowProperties,n.knowEvents);a.initialize?a.initialize(i):copy(a,i,!1,!0);for(let n in e.customProps)void 0!==c[n]&&e.customProps[n](a,c[n]);(e=>{o.current=updateChildProperties({controlRef:{current:a},childInfo:o.current},e)})(r.children||[])};updateProps(e.props||[]);e.props.initialized&&isFunction(e.props.initialized)&&e.props.initialized(a);return{instance:a,updateProps:updateProps}},props:e.props,parentProp:e.parentProp,wjProperty:e.props.wjProperty,isParentPropArray:e.isParentPropArray,assignedToParent:e.assignedToParent}}let _reactMajorVersion,elemRootMap=[];if(!_reactMajorVersion){const e=parseInt(React.version);_reactMajorVersion=e;e>=18&&lazyImportDomClient()}const flushSyncStateCache={isReactRendering:null};function isReactRendering(){if(null==flushSyncStateCache.isReactRendering)try{const e=console.error;let n=!1;console.error=function(){const e=arguments[0]||"";e.includes("flushSync")&&(n=!0)};flushSync(()=>{});console.error=e;flushSyncStateCache.isReactRendering=n}catch(e){}finally{queueMicrotask(()=>{flushSyncStateCache.isReactRendering=null})}return!!flushSyncStateCache.isReactRendering}function getReactDOM(){return ReactDOM}export function selectiveDomRender(e,n,r=!1){if(_reactMajorVersion<18){(0,getReactDOM().render)(e,n)}else{isReactRendering()&&(r=!0);const t=elemRootMap.findIndex(e=>e.host===n);let o;if(-1===t){o=reactDomClient.createRoot(n);elemRootMap.push({host:n,root:o})}else o=elemRootMap[t].root;o.__scheduledForUnmount=!1;r?queueMicrotask(()=>{flushSync(()=>{o.render(e)})}):flushSync(()=>{o.render(e)})}return n}function unmountSafely(e){const n=e._internalRoot&&e._internalRoot.containerInfo.firstChild,r=e._internalRoot&&e._internalRoot.current&&e._internalRoot.current.child&&e._internalRoot.current.child.stateNode;r&&n==r?e.unmount():e._internalRoot=null;e.__scheduledForUnmount=null}export function selectiveDomUnmount(e){if(_reactMajorVersion<18){(0,getReactDOM().unmountComponentAtNode)(e)}else{const n=elemRootMap.findIndex(n=>n.host===e);if(-1!==n){const e=elemRootMap[n].root;if(isReactRendering()){e.__scheduledForUnmount=!0;queueMicrotask(()=>{e.__scheduledForUnmount&&flushSync(()=>{unmountSafely(e);elemRootMap.splice(n,1)})})}else flushSync(()=>{unmountSafely(e);elemRootMap.splice(n,1)})}}}export function baseFlushSync(){flushSync(()=>{})}